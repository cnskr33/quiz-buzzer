<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Quizshow – Zeitstrahl</title>

<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>

<script>
const firebaseConfig = {
  apiKey: "AIzaSyCob25y3pT7O6wjf21l9xiaCXhGMFLzFQg",
  authDomain: "testprojekt-dada3.firebaseapp.com",
  databaseURL: "https://testprojekt-dada3-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "testprojekt-dada3",
  storageBucket: "testprojekt-dada3.appspot.com",
  messagingSenderId: "651866459764",
  appId: "1:651866459764:web:ed23cf3fd5ccf02a42cb21"
};

firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// Spieler-ID holen
const params = new URLSearchParams(window.location.search);
let playerId = params.get("id") || sessionStorage.getItem("playerId");

if(!playerId){
  window.location.href = "index.html";
}

const playerRef = db.ref("players/" + playerId);
const playerName = sessionStorage.getItem("playerName") || "Spieler";

playerRef.set({
  name: playerName,
  lives: 2,
  joinedAt: Date.now()
});

// HOST LOGIK
const hostRef = db.ref("game/host");

hostRef.transaction(currentHost => {
  if(currentHost === null){
    return playerId; // erster Spieler wird Host
  }
  return currentHost;
});

// Wenn erster Host → Runde auf 0 setzen
db.ref("game/currentRound").once("value").then(snap => {
  if(snap.val() === null){
    db.ref("game/currentRound").set(0);
  }
});
  
// Host löschen wenn er disconnectet
playerRef.onDisconnect().remove();

hostRef.on("value", snap => {
  const hostId = snap.val();
  window.isHost = (hostId === playerId);
});

playerRef.onDisconnect().remove();

</script>

<style>
body{margin:0;background:#0b1020;color:#e9eefc;font-family:system-ui}
.app{display:grid;grid-template-rows:auto 1fr auto;gap:16px;padding:16px;height:100vh;box-sizing:border-box}
.card{background:rgba(255,255,255,0.06);border:1px solid rgba(255,255,255,0.12);border-radius:16px;padding:16px}
.timeline{display:grid;gap:10px;margin-top:12px}
.slot{border-radius:16px;border:1px dashed rgba(255,255,255,0.3);min-height:170px;padding:10px;display:grid;grid-template-rows:24px 1fr}
.slotHeader{text-align:center;font-weight:900}
.slotBody{display:grid;place-items:center}
.pool{display:grid;grid-template-columns:repeat(8,minmax(120px,1fr));gap:10px;margin-top:8px}
.cardItem{border-radius:16px;border:1px solid rgba(255,255,255,0.12);background:rgba(0,0,0,0.22);padding:10px;display:grid;gap:8px;justify-items:center;cursor:grab}
.cardItem img{width:72px;height:72px;border-radius:12px;object-fit:cover}
.cardItem[data-status="pending"]{outline:2px solid gold}
.cardItem[data-status="fixed"]{outline:2px solid limegreen}
.scoreboard{display:grid;grid-template-columns:repeat(5,minmax(160px,1fr));gap:10px}
.player{padding:10px;border-radius:14px;background:rgba(0,0,0,0.2);border:1px solid rgba(255,255,255,0.1)}
.hearts{font-size:18px;margin-top:4px}
button{padding:8px 12px;border-radius:8px;border:1px solid rgba(255,255,255,0.2);background:rgba(255,255,255,0.1);color:#e9eefc;cursor:pointer}
button:hover{background:rgba(255,255,255,0.2)}
</style>
</head>


<body>
<div class="app">

<div class="card">
<h2 id="title"></h2>

<div>
<button onclick="checkPlacement()">Überprüfen</button>
<button onclick="randomizeStart()">Zufällig</button>
<button id="nextRoundBtn" onclick="nextRound()">Nächste Runde</button>
<button id="resetBtn" onclick="resetPlayers()">Spieler Reset</button>
</div>


<div id="timeline" class="timeline"></div>

<h3>Pool</h3>
<div id="pool" class="pool"></div>
</div>

<div class="card">
<h3>Spieler</h3>
<div id="players" class="scoreboard"></div>
</div>

</div>

<script>
const rounds=[
{
title:"Runde 1 – Marktwerte (Mio €)",
items:[
{id:"yamal",name:"Lamine Yamal",value:258.4,img:"assets/lamine_yamal.jpg"},
{id:"mbappe",name:"Kylian Mbappé",value:192.1,img:"assets/kylian_mbappe.jpg"},
{id:"vinicius",name:"Vinicius Junior",value:182.7,img:"assets/vinicius_junior.jpg"},
{id:"haaland",name:"Erling Haaland",value:177.9,img:"assets/erling_haaland.jpg"},
{id:"bellingham",name:"Jude Bellingham",value:177.1,img:"assets/jude_bellingham.jpg"},
{id:"olise",name:"Michael Olise",value:156.7,img:"assets/michael_olise.jpg"},
{id:"pedri",name:"Pedri",value:142.3,img:"assets/pedri.jpg"},
{id:"palmer",name:"Cole Palmer",value:138.7,img:"assets/cole_palmer.jpg"},
{id:"musiala",name:"Jamal Musiala",value:130.7,img:"assets/jamal_musiala.jpg"},
{id:"wirtz",name:"Florian Wirtz",value:126.5,img:"assets/florian_wirtz.jpg"},
{id:"saka",name:"Bukayo Saka",value:123.0,img:"assets/bukayo_saka.jpg"},
{id:"cubarsi",name:"Pau Cubarsí",value:122.9,img:"assets/pau_cubarsi.jpg"},
{id:"rice",name:"Declan Rice",value:121.1,img:"assets/declan_rice.jpg"},
{id:"gyokeres",name:"Viktor Gyökeres",value:120.1,img:"assets/viktor_gyokeres.jpg"},
{id:"joaoneves",name:"João Neves",value:129.7,img:"assets/joao_neves.jpg"}
]
}
];

let currentRound=0;
let slotPlacements=[];
let statusById={};
let poolOrder=[];
let lastPlacedId=null;
window.isHost = false;

  
function initRound(){
  const r = rounds[currentRound];
  document.getElementById("title").innerText = r.title;

  if(!window.isHost) return;

  // Nur Slots speichern (Pool wird berechnet)
  let slots = Array(r.items.length).fill(null);

  // zufällige Startkarte in die Mitte
  const ids = r.items.map(x => x.id);
  shuffle(ids);

  const mid = Math.floor(slots.length / 2);
  slots[mid] = ids[0];

  db.ref("game/state").set({
    slots: slots
  });
}



function seedMiddle(){
const mid=Math.floor(slotPlacements.length/2);
const id=poolOrder.pop();
slotPlacements[mid]=id;
statusById[id]="fixed";
}

function randomizeStart(){
initRound();
}

function renderAll(){
renderTimeline();
renderPool();
}

function renderTimeline(){
const timeline=document.getElementById("timeline");

// Wenn noch kein State da ist, trotzdem Slots anzeigen
const len = (slotPlacements && slotPlacements.length) ? slotPlacements.length : rounds[currentRound].items.length;

timeline.style.gridTemplateColumns=`repeat(${len},minmax(64px,1fr))`;
timeline.innerHTML="";

for(let i=0;i<len;i++){
  const id = slotPlacements[i] || null;
  
const slot=document.createElement("div");
slot.className="slot";
const header=document.createElement("div");
header.className="slotHeader";
header.innerText=i+1;
const body=document.createElement("div");
body.className="slotBody";
if(id){
body.appendChild(makeCard(getItem(id),true));
}else{
body.innerText="Drop";
}
slot.appendChild(header);
slot.appendChild(body);
slot.ondragover=e=>e.preventDefault();
slot.ondrop=e=>{
e.preventDefault();
const dropped=e.dataTransfer.getData("id");
insertWithShift(i,dropped);
renderAll();
};
timeline.appendChild(slot);
}
}

function renderPool(){
  const pool = document.getElementById("pool");
  pool.innerHTML = "";

  // Pool dynamisch berechnen: alle Items - alles was in slots liegt
  const allIds = rounds[currentRound].items.map(x => x.id);
  const inSlots = new Set((slotPlacements || []).filter(Boolean));
  const poolIds = allIds.filter(id => !inSlots.has(id));

  // Optional: mischen, damit Pool nicht immer gleich aussieht
  shuffle(poolIds);

  poolIds.forEach(id => {
    pool.appendChild(makeCard(getItem(id), false));
  });
}

function makeCard(item,inSlot){
const card=document.createElement("div");
card.className="cardItem";
card.dataset.status=statusById[item.id]||"pool";
card.draggable=true;
card.innerHTML=`<img src="${item.img}"><div>${item.name}</div>`;
card.ondragstart=e=>e.dataTransfer.setData("id",item.id);
return card;
}

function insertWithShift(index, id){
  if(!window.isHost) return;

  const stateRef = db.ref("game/state");

  stateRef.transaction(state => {
    if(!state || !state.slots) return state;

    // Slots als echtes Array absichern (falls Firebase Objekt liefert)
    let slots = Array.isArray(state.slots) ? state.slots : Object.values(state.slots);

    const existing = slots.indexOf(id);
    if(existing !== -1) slots[existing] = null;

    slots[index] = id;

    return { slots: slots };
  });
}

function checkPlacement(){
  if(!window.isHost) return;

  const stateRef = db.ref("game/state");

  stateRef.once("value").then(snap => {
    const state = snap.val();
    if(!state || !state.slots) return;

    const slots = Array.isArray(state.slots) ? state.slots : Object.values(state.slots);
    const values = slots.map(id => id ? getItem(id).value : null);

    for(let i = 1; i < values.length; i++){
      if(values[i] !== null && values[i-1] !== null && values[i] < values[i-1]){
        // falscher Slot = der aktuelle i
        const wrongId = slots[i];
        slots[i] = null;

        stateRef.set({ slots: slots });
        loseLife();
        return;
      }
    }
  });
}

function loseLife(){
playerRef.transaction(data=>{
if(!data)return data;
data.lives=(data.lives||2)-1;
if(data.lives<0)data.lives=0;
return data;
});
}

function getItem(id){
return rounds[currentRound].items.find(x=>x.id===id);
}

function shuffle(arr){
for(let i=arr.length-1;i>0;i--){
const j=Math.floor(Math.random()*(i+1));
[arr[i],arr[j]]=[arr[j],arr[i]];
}
}

function nextRound(){
  if(!window.isHost) return;

  const roundRef = db.ref("game/currentRound");

  roundRef.transaction(current => {
    if(current === null) return 1;
    let next = current + 1;
    if(next >= rounds.length) next = 0;
    return next;
  });
}
  
function resetPlayers(){
  if(confirm("Wirklich alle Spieler zurücksetzen?")){
    db.ref("players").remove();
  }
}
 
/* Spieler Anzeige */
db.ref("players").on("value",snap=>{
const container=document.getElementById("players");
container.innerHTML="";

snap.forEach(child=>{
const data = child.val();

if(!data || !data.name){
  // Zombie-Eintrag -> direkt löschen
  db.ref("players/"+child.key).remove();
  return;
}

const div=document.createElement("div");
div.className="player";
div.innerHTML=`
<strong>${data.name}</strong>
<div class="hearts">${"❤️".repeat(data.lives||2)}</div>
`;
container.appendChild(div);
});
});



// Host-UI + Init
db.ref("game/host").on("value", snap => {
  const hostId = snap.val();
  window.isHost = (hostId === playerId);

  const nextBtn = document.getElementById("nextRoundBtn");
  const resetBtn = document.getElementById("resetBtn");

  if(!window.isHost){
    if(nextBtn) nextBtn.style.display = "none";
    if(resetBtn) resetBtn.style.display = "none";
    return;
  }

  // Wenn ich Host bin -> Runde sicherstellen
  db.ref("game/currentRound").transaction(cur => {
    if(cur === null) return 0;
    return cur;
  }).then(() => {
   db.ref("game/currentRound").once("value").then(s => {
  currentRound = s.val() ?? 0;

  // State nur erzeugen, wenn noch keiner existiert
  db.ref("game/state").once("value").then(st => {
    if(!st.exists()){
      initRound();
    }
  });
});

  
// Globale Rundensynchronisation
db.ref("game/currentRound").on("value", snap => {
  const value = snap.val();
  if(value === null) return;

  currentRound = value;
});

db.ref("game/state").on("value", snap => {
  const state = snap.val();
  if(!state || !state.slots) return;

  slotPlacements = Array.isArray(state.slots)
    ? state.slots
    : Object.values(state.slots || {});

  renderAll();
});

</script>
</body>
</html>
