<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Quizshow ‚Äì Spiel</title>

  <!-- Firebase (compat) -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>

  <script>
    // ========= FIREBASE CONFIG (HIER DEINE ECHTEN DATEN EINTRAGEN) =========
    const firebaseConfig = {
      apiKey: "DEIN_API_KEY",
      authDomain: "DEIN_PROJECT.firebaseapp.com",
      databaseURL: "https://testprojekt-dada3-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "DEIN_PROJECT_ID",
      storageBucket: "DEIN_PROJECT.appspot.com",
      messagingSenderId: "XXXX",
      appId: "XXXX"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();
  </script>

  <style>
    :root { font-family: system-ui, Arial, sans-serif; }
    body { margin: 0; background: #0b1020; color: #e9eefc; }

    /* Top players bar */
    .playersBar{
      position: sticky;
      top: 0;
      z-index: 50;
      background: rgba(12, 18, 40, 0.92);
      border-bottom: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(8px);
      padding: 10px 12px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .pCard{
      display:flex;
      flex-direction:column;
      gap:4px;
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(0,0,0,0.22);
      min-width: 140px;
    }
    .pName{ font-weight: 900; font-size: 13.5px; }
    .pMeta{ opacity:.9; font-size: 13px; display:flex; justify-content:space-between; gap:10px; }
    .pActive{ outline: 2px solid rgba(120, 190, 255, 0.55); outline-offset: 2px; }
    .meTag{ font-size: 12px; opacity:.85; }

    .app{
      display:grid;
      grid-template-rows: 1fr auto;
      gap:16px;
      padding:16px;
      height: calc(100vh - 60px);
      box-sizing:border-box;
    }

    .card{
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 16px;
      padding: 16px;
      overflow: auto;
      position: relative;
    }

    h1 { font-size: 22px; margin: 0; }
    h2 { font-size: 16px; margin: 14px 0 10px; opacity: 0.92; }
    .hint { opacity: 0.75; font-size: 13px; line-height: 1.4; margin: 6px 0 0; }

    input, button{
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color: #e9eefc;
      padding: 10px 12px;
      font-size: 14px;
    }
    input { flex: 1; min-width: 180px; }
    button { cursor:pointer; }
    button:hover { background: rgba(255,255,255,0.14); }
    .danger { border-color: rgba(255,80,80,0.35); }
    button:disabled { opacity: 0.55; cursor: not-allowed; }

    /* Flash overlay */
    .flash {
      position: absolute;
      inset: 0;
      border-radius: 16px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 140ms ease;
    }
    .flash.on { opacity: 0.28; }
    .flash.green { background: rgba(0, 255, 120, 0.55); }
    .flash.red { background: rgba(255, 40, 60, 0.60); }

    /* Top bar */
    .topBar{
      display:flex;
      align-items:flex-start;
      justify-content: space-between;
      gap: 12px;
    }
    .topRight{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .badge{
      padding: 8px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.18);
      font-weight: 800;
      min-width: 62px;
      text-align:center;
    }
    .turnBadge{
      max-width: 460px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      text-align: left;
      min-width: 260px;
    }

    .topRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
      margin-top: 10px;
    }

    /* Timeline */
    .timeline{
      display:grid;
      gap: 10px;
      align-items: stretch;
      margin-top: 12px;
    }

    .slot{
      border-radius: 16px;
      border: 1px dashed rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.18);
      min-height: 170px;
      padding: 10px;
      display: grid;
      grid-template-rows: 24px 1fr;
      gap: 10px;
      user-select: none;
    }

    .slotHeader{
      height: 24px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight: 900;
      font-size: 14px;
      opacity: 0.95;
    }

    .slot.dropOver { outline: 2px solid rgba(255,255,255,0.35); outline-offset: 2px; }

    .slotBody{ display:grid; place-items: center; width: 100%; height: 100%; }
    .emptyDrop{ opacity: 0.7; font-size: 13px; text-align:center; }

    /* Cards */
    .pool{
      display:grid;
      grid-template-columns: repeat(8, minmax(120px, 1fr));
      gap: 10px;
      margin-top: 8px;
    }

    .cardItem{
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.22);
      padding: 10px;
      display: grid;
      grid-template-rows: auto auto auto;
      gap: 8px;
      justify-items: center;
      cursor: grab;
      user-select: none;
    }
    .cardItem:active { cursor: grabbing; }

    .cardItem[data-status="pending"] { outline: 2px solid rgba(255, 220, 80, 0.55); outline-offset: 2px; }
    .cardItem[data-status="fixed"]   { outline: 2px solid rgba(120, 255, 180, 0.35); outline-offset: 2px; }

    .avatar{
      width: 72px;
      height: 72px;
      max-width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.08);
      object-fit: cover;
    }
    .label{
      font-weight: 900;
      font-size: 12.8px;
      line-height: 1.2;
      text-align: center;
    }

    /* Bottom area card */
    .footerCard{
      display:flex;
      gap:10px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: space-between;
    }
    .smallHint{ opacity:.75; font-size: 13px; }
  </style>
</head>

<body>

  <!-- Spieler-Bar (aus Firebase Join) -->
  <div class="playersBar" id="playersBar">
    <div style="opacity:.8;font-size:13px;">Spieler laden‚Ä¶</div>
  </div>

  <div class="app">
    <div class="card" id="gameCard">
      <div class="flash" id="flash"></div>

      <div class="topBar">
        <div>
          <h1 id="title">Runde</h1>
          <div class="hint" id="hint"></div>
        </div>

        <div class="topRight">
          <div class="badge turnBadge" id="turnBadge">Am Zug: ‚Äî</div>
          <div class="badge" id="roundBadge">1/4</div>
          <button id="randomBtn" title="Startkarte neu zuf√§llig + Pool mischen">Zuf√§llig</button>
          <button id="nextRound">N√§chste Runde</button>
        </div>
      </div>

      <div class="topRow">
        <button id="checkBtn">√úberpr√ºfen</button>
        <button id="solutionBtn" disabled>L√∂sung</button>
        <button id="resetTimeline" class="danger">Zeitstrahl zur√ºcksetzen</button>
        <button id="shufflePool">Karten mischen</button>
      </div>

      <div id="timeline" class="timeline"></div>

      <h2>Pool</h2>
      <div id="pool" class="pool"></div>

      <div class="hint" style="margin-top:10px;">
        Gelb = zuletzt gesetzte Karte ¬∑ Gr√ºn = best√§tigt/fix ¬∑ Werte sieht man nur in der L√∂sung
      </div>
    </div>

    <div class="card footerCard">
      <div>
        <div style="font-weight:900;">Info</div>
        <div class="smallHint" id="meInfo"></div>
      </div>
      <div class="smallHint">
        Tipp: Bilder m√ºssen im Repo unter <b>/assets</b> liegen (wie du es schon gemacht hast).
      </div>
    </div>
  </div>

  <script>
    /** =======================
     *  SPIELER (Firebase Join)
     *  ======================= */
    const urlParams = new URLSearchParams(window.location.search);
    const MY_NAME = (urlParams.get("name") || "").trim();

    if(!MY_NAME){
      alert("Kein Name √ºbergeben. Bitte √ºber index.html einw√§hlen.");
      // zur Sicherheit zur√ºck:
      window.location.href = "index.html";
    }

    document.getElementById("meInfo").textContent = `Du bist eingeloggt als: ${MY_NAME}`;

    const LIVES_PER_ROUND = 2;

    let firebasePlayers = []; // [{name, lives, score, joinedAt}]
    let currentTurnIndex = 0; // lokal (Gamemaster/Host steuert)

    function renderPlayersBar(){
      const bar = document.getElementById("playersBar");
      bar.innerHTML = "";

      if(firebasePlayers.length === 0){
        bar.innerHTML = `<div style="opacity:.8;font-size:13px;">Noch keine Spieler‚Ä¶</div>`;
        return;
      }

      const current = getCurrentPlayer();
      for(const p of firebasePlayers){
        const div = document.createElement("div");
        div.className = "pCard" + (current && current.name === p.name ? " pActive" : "");
        const hearts = "‚ù§Ô∏è".repeat(p.lives) + "ü§ç".repeat(Math.max(0, LIVES_PER_ROUND - p.lives));
        div.innerHTML = `
          <div class="pName">${escapeHtml(p.name)} ${p.name === MY_NAME ? `<span class="meTag">(du)</span>` : ""}</div>
          <div class="pMeta">
            <span>${hearts}</span>
            <span>üèÜ ${p.score ?? 0}</span>
          </div>
        `;
        bar.appendChild(div);
      }
    }

    function syncPlayers(){
      db.ref("players").on("value", snap => {
        const list = [];
        snap.forEach(child => {
          const val = child.val() || {};
          list.push({
            name: child.key,
            lives: Number(val.lives ?? LIVES_PER_ROUND),
            score: Number(val.score ?? 0),
            joinedAt: Number(val.joinedAt ?? 0)
          });
        });

        // stabile Reihenfolge: nach joinedAt, fallback name
        list.sort((a,b) => (a.joinedAt - b.joinedAt) || a.name.localeCompare(b.name));
        firebasePlayers = list;

        // Turn-Index im Rahmen halten
        if(currentTurnIndex >= firebasePlayers.length) currentTurnIndex = 0;

        renderPlayersBar();
        updateTurnUI();
        updateSolutionButton();
      });
    }

    function getCurrentPlayer(){
      if(firebasePlayers.length === 0) return null;

      // wenn alle raus -> null
      const anyAlive = firebasePlayers.some(p => (p.lives ?? 0) > 0);
      if(!anyAlive) return null;

      // finde n√§chsten lebenden ab currentTurnIndex
      let tries = 0;
      let idx = currentTurnIndex;
      while(tries < firebasePlayers.length && (firebasePlayers[idx].lives ?? 0) <= 0){
        idx = (idx + 1) % firebasePlayers.length;
        tries++;
      }
      currentTurnIndex = idx;
      return firebasePlayers[currentTurnIndex];
    }

    function advanceTurn(){
      if(firebasePlayers.length === 0){
        currentTurnIndex = 0;
        updateTurnUI();
        renderPlayersBar();
        updateSolutionButton();
        return;
      }

      // wenn alle raus -> fertig
      const anyAlive = firebasePlayers.some(p => (p.lives ?? 0) > 0);
      if(!anyAlive){
        document.getElementById("turnBadge").textContent = "Runde vorbei (alle ausgeschieden)";
        renderPlayersBar();
        updateSolutionButton();
        return;
      }

      // n√§chster lebender
      for(let step=1; step<=firebasePlayers.length; step++){
        const idx = (currentTurnIndex + step) % firebasePlayers.length;
        if((firebasePlayers[idx].lives ?? 0) > 0){
          currentTurnIndex = idx;
          break;
        }
      }

      updateTurnUI();
      renderPlayersBar();
      updateSolutionButton();
    }

    function updateTurnUI(){
      const badge = document.getElementById("turnBadge");
      const p = getCurrentPlayer();
      badge.textContent = p ? `Am Zug: ${p.name}` : "Am Zug: ‚Äî";
    }

    async function loseLife(playerName){
      if(!playerName) return;
      const ref = db.ref("players/" + playerName + "/lives");
      const snap = await ref.get();
      let lives = Number(snap.val() ?? LIVES_PER_ROUND);
      lives = Math.max(0, lives - 1);
      await ref.set(lives);
    }

    async function addScore(playerName, delta){
      if(!playerName) return;
      const ref = db.ref("players/" + playerName + "/score");
      const snap = await ref.get();
      let score = Number(snap.val() ?? 0);
      score = score + delta;
      await ref.set(score);
    }

    async function resetLivesForAllPlayers(){
      const updates = {};
      for(const p of firebasePlayers){
        updates["players/" + p.name + "/lives"] = LIVES_PER_ROUND;
      }
      await db.ref().update(updates);
      currentTurnIndex = 0;
    }

    /** =======================
     *  RUNDEN / SPIELLOGIK
     *  ======================= */

    // Runde 1: Fu√üball
    const roundFootball = {
      id: "football",
      title: "Runde 1: Top 15 Fu√üballer (Marktwert)",
      hint: "Links = niedriger Marktwert, rechts = h√∂her. Startkarte wird automatisch mittig gesetzt.",
      unit: "Mio ‚Ç¨",
      decimals: 1,
      slotCount: 15,
      items: [
        { id:"yamal", name:"Lamine Yamal", value:258.4, img:"assets/lamine_yamal.jpg" },
        { id:"mbappe", name:"Kylian Mbapp√©", value:192.1, img:"assets/kylian_mbappe.jpg" },
        { id:"vinicius", name:"Vinicius Junior", value:182.7, img:"assets/vinicius_junior.jpg" },
        { id:"haaland", name:"Erling Haaland", value:177.9, img:"assets/erling_haaland.jpg" },
        { id:"bellingham", name:"Jude Bellingham", value:177.1, img:"assets/jude_bellingham.jpg" },
        { id:"olise", name:"Michael Olise", value:156.7, img:"assets/michael_olise.jpg" },
        { id:"pedri", name:"Pedri", value:142.3, img:"assets/pedri.jpg" },
        { id:"palmer", name:"Cole Palmer", value:138.7, img:"assets/cole_palmer.jpg" },
        { id:"musiala", name:"Jamal Musiala", value:130.7, img:"assets/jamal_musiala.jpg" },
        { id:"joaoneves", name:"Jo√£o Neves", value:129.7, img:"assets/joao_neves.jpg" },
        { id:"wirtz", name:"Florian Wirtz", value:126.5, img:"assets/florian_wirtz.jpg" },
        { id:"saka", name:"Bukayo Saka", value:123.0, img:"assets/bukayo_saka.jpg" },
        { id:"cubarsi", name:"Pau Cubars√≠", value:122.9, img:"assets/pau_cubarsi.jpg" },
        { id:"rice", name:"Declan Rice", value:121.1, img:"assets/declan_rice.jpg" },
        { id:"gyokeres", name:"Viktor Gy√∂keres", value:120.1, img:"assets/viktor_gyokeres.jpg" },
      ],
    };

    // Runde 2: Platzhalter (wie gew√ºnscht)
    const roundPlaceholder = {
      id: "placeholder",
      title: "Runde 2: Platzhalter",
      hint: "Hier kommt sp√§ter ein anderes Thema rein (z.B. Filme, Einnahmen, etc.).",
      unit: "",
      decimals: 0,
      slotCount: 10,
      items: [
        { id:"p1", name:"Platzhalter 1", value:10, img:"assets/placeholder.png" },
        { id:"p2", name:"Platzhalter 2", value:20, img:"assets/placeholder.png" },
        { id:"p3", name:"Platzhalter 3", value:30, img:"assets/placeholder.png" },
        { id:"p4", name:"Platzhalter 4", value:40, img:"assets/placeholder.png" },
        { id:"p5", name:"Platzhalter 5", value:50, img:"assets/placeholder.png" },
        { id:"p6", name:"Platzhalter 6", value:60, img:"assets/placeholder.png" },
        { id:"p7", name:"Platzhalter 7", value:70, img:"assets/placeholder.png" },
        { id:"p8", name:"Platzhalter 8", value:80, img:"assets/placeholder.png" },
        { id:"p9", name:"Platzhalter 9", value:90, img:"assets/placeholder.png" },
        { id:"p10", name:"Platzhalter 10", value:100, img:"assets/placeholder.png" },
      ],
    };

    const rounds = [roundFootball, roundPlaceholder];
    const TOTAL_ROUNDS_BADGE = 4; // wie in deinem UI (auch wenn nur 2 existieren)

    let currentRoundIndex = 0;

    let slotPlacements = [];
    let statusById = {};
    let poolOrder = [];
    let lastPlacedId = null;

    let solutionShown = false;

    function getRound(){ return rounds[currentRoundIndex]; }

    function shuffle(arr){
      const a = [...arr];
      for (let i = a.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function setFlash(color){
      const el = document.getElementById("flash");
      el.classList.remove("green","red","on");
      el.classList.add(color);
      requestAnimationFrame(() => el.classList.add("on"));
      setTimeout(() => el.classList.remove("on"), 180);
    }

    function itemById(id){ return getRound().items.find(x => x.id === id); }
    function indexOfItem(id){ return slotPlacements.findIndex(x => x === id); }
    function placedIds(){ return new Set(slotPlacements.filter(Boolean)); }

    function formatValue(v){
      const r = getRound();
      if(!r.unit) return String(v);
      const nf = new Intl.NumberFormat("de-DE", { minimumFractionDigits: r.decimals, maximumFractionDigits: r.decimals });
      return `${nf.format(v)} ${r.unit}`;
    }

    function updateRoundUI(){
      const r = getRound();
      document.getElementById("title").textContent = r.title;
      document.getElementById("hint").textContent = r.hint;
      document.getElementById("roundBadge").textContent = `${currentRoundIndex + 1}/${TOTAL_ROUNDS_BADGE}`;

      const timeline = document.getElementById("timeline");
      timeline.style.gridTemplateColumns = `repeat(${r.slotCount}, minmax(64px, 1fr))`;
    }

    function initRound(index){
      currentRoundIndex = index;
      updateRoundUI();

      const r = getRound();
      slotPlacements = Array.from({ length: r.slotCount }, () => null);
      statusById = Object.fromEntries(r.items.map(it => [it.id, "pool"]));
      poolOrder = shuffle(r.items.map(x => x.id));
      lastPlacedId = null;
      solutionShown = false;

      seedMiddleFixed();
      renderAll();
      updateSolutionButton();
      updateTurnUI();
    }

    function seedMiddleFixed(){
      const r = getRound();
      const mid = Math.floor(r.slotCount / 2);
      const pick = r.items[Math.floor(Math.random() * r.items.length)].id;
      slotPlacements[mid] = pick;
      statusById[pick] = "fixed";
    }

    async function nextRound(){
      const next = currentRoundIndex + 1;
      if (next >= rounds.length){
        alert("Weitere Runden (3/4, 4/4) sind noch nicht angelegt.");
        return;
      }
      await resetLivesForAllPlayers();
      initRound(next);
    }

    async function resetTimeline(){
      const r = getRound();
      slotPlacements = Array.from({ length: r.slotCount }, () => null);
      for (const it of r.items) statusById[it.id] = "pool";
      poolOrder = shuffle(r.items.map(x => x.id));
      lastPlacedId = null;
      solutionShown = false;

      seedMiddleFixed();
      await resetLivesForAllPlayers();

      renderAll();
      updateSolutionButton();
      updateTurnUI();
    }

    function randomizeStart(){
      // Startkarte neu + Pool mischen
      const r = getRound();
      slotPlacements = Array.from({ length: r.slotCount }, () => null);
      for (const it of r.items) statusById[it.id] = "pool";
      poolOrder = shuffle(r.items.map(x => x.id));
      lastPlacedId = null;
      solutionShown = false;

      seedMiddleFixed();
      renderAll();
      updateSolutionButton();
    }

    /** ========= INSERT / GAP CLOSE ========= */
    function insertWithShift(targetIndex, droppedId){
      const existingIndex = indexOfItem(droppedId);
      if (existingIndex !== -1) slotPlacements[existingIndex] = null;

      if (!slotPlacements[targetIndex]){
        slotPlacements[targetIndex] = droppedId;
        return true;
      }

      let emptyRight = -1;
      for (let k = targetIndex; k < slotPlacements.length; k++){
        if (slotPlacements[k] === null) { emptyRight = k; break; }
      }
      if (emptyRight !== -1){
        for (let k = emptyRight; k > targetIndex; k--){
          slotPlacements[k] = slotPlacements[k - 1];
        }
        slotPlacements[targetIndex] = droppedId;
        return true;
      }

      let emptyLeft = -1;
      for (let k = targetIndex; k >= 0; k--){
        if (slotPlacements[k] === null) { emptyLeft = k; break; }
      }
      if (emptyLeft !== -1){
        for (let k = emptyLeft; k < targetIndex; k++){
          slotPlacements[k] = slotPlacements[k + 1];
        }
        slotPlacements[targetIndex] = droppedId;
        return true;
      }

      return false;
    }

    function closeGapFromIndex(startIndex){
      for (let i = startIndex; i < slotPlacements.length; i++){
        if (slotPlacements[i] !== null) continue;

        let j = i + 1;
        while (j < slotPlacements.length && slotPlacements[j] === null) j++;
        if (j >= slotPlacements.length) return;

        slotPlacements[i] = slotPlacements[j];
        slotPlacements[j] = null;
      }
    }

    /** ========= CHECK / SOLUTION ========= */
    function isPlacementConsistent(){
      const placed = slotPlacements
        .map((id, idx) => ({ id, idx }))
        .filter(x => x.id !== null)
        .map(x => ({ ...x, value: itemById(x.id).value }));

      for (let i = 0; i < placed.length; i++){
        for (let j = i + 1; j < placed.length; j++){
          const a = placed[i], b = placed[j];
          if (a.value === b.value) continue;
          if (a.value < b.value && !(a.idx < b.idx)) return false;
          if (a.value > b.value && !(a.idx > b.idx)) return false;
        }
      }
      return true;
    }

    function getCorrectOrderIds(){
      const r = getRound();
      return [...r.items]
        .sort((a,b) => (a.value - b.value) || a.name.localeCompare(b.name))
        .map(x => x.id);
    }

    function showSolution(){
      const r = getRound();
      const ids = getCorrectOrderIds();
      slotPlacements = Array.from({ length: r.slotCount }, (_, i) => ids[i] ?? null);

      for (const it of r.items) statusById[it.id] = "fixed";
      lastPlacedId = null;
      solutionShown = true;

      renderAll();
      document.getElementById("turnBadge").textContent = "L√∂sung angezeigt";
      updateSolutionButton();
    }

    function updateSolutionButton(){
      const btn = document.getElementById("solutionBtn");
      const anyAlive = firebasePlayers.some(p => (p.lives ?? 0) > 0);
      btn.disabled = anyAlive || firebasePlayers.length === 0;
    }

    async function verify(){
      if (!lastPlacedId) return;
      if (solutionShown) return;

      const ok = isPlacementConsistent();
      const p = getCurrentPlayer();

      if (ok){
        statusById[lastPlacedId] = "fixed";
        setFlash("green");

        if (p) await addScore(p.name, +1);

        lastPlacedId = null;
        renderAll();
        advanceTurn();
      } else {
        const idx = indexOfItem(lastPlacedId);
        if (idx !== -1) slotPlacements[idx] = null;
        if (idx !== -1) closeGapFromIndex(idx);

        statusById[lastPlacedId] = "pool";
        lastPlacedId = null;

        poolOrder = shuffle(poolOrder);
        setFlash("red");
        renderAll();

        if (p) await loseLife(p.name);

        advanceTurn();
      }
    }

    /** ========= RENDER ========= */
    function renderAll(){
      renderTimeline();
      renderPool();
    }

    function renderTimeline(){
      const r = getRound();
      const timeline = document.getElementById("timeline");
      timeline.innerHTML = "";

      for (let i = 0; i < r.slotCount; i++){
        const slot = document.createElement("div");
        slot.className = "slot";

        const header = document.createElement("div");
        header.className = "slotHeader";
        header.textContent = String(i + 1);

        const body = document.createElement("div");
        body.className = "slotBody";

        const id = slotPlacements[i];
        if (id){
          body.appendChild(makeCard(itemById(id), true));
        } else {
          const empty = document.createElement("div");
          empty.className = "emptyDrop";
          empty.textContent = "Drop";
          body.appendChild(empty);
        }

        slot.addEventListener("dragover", (e) => {
          e.preventDefault();
          slot.classList.add("dropOver");
        }, true);

        slot.addEventListener("dragleave", () => slot.classList.remove("dropOver"), true);

        slot.addEventListener("drop", (e) => {
          e.preventDefault();
          slot.classList.remove("dropOver");
          if (solutionShown) return;

          const droppedId = e.dataTransfer.getData("text/itemId");
          if (!droppedId) return;

          const ok = insertWithShift(i, droppedId);
          if (!ok) return;

          lastPlacedId = droppedId;
          statusById[droppedId] = "pending";
          renderAll();
        }, true);

        slot.appendChild(header);
        slot.appendChild(body);
        timeline.appendChild(slot);
      }
    }

    function renderPool(){
      const pool = document.getElementById("pool");
      pool.innerHTML = "";
      if (solutionShown) return;

      const placed = placedIds();
      for (const id of poolOrder){
        if (placed.has(id)) continue;
        if (statusById[id] !== "pool") continue;
        pool.appendChild(makeCard(itemById(id), false));
      }
    }

    function makeCard(item, inSlot){
      const card = document.createElement("div");
      card.className = "cardItem";
      card.draggable = true;
      card.dataset.status = statusById[item.id] || "pool";

      const img = document.createElement("img");
      img.className = "avatar";
      img.alt = item.name;
      img.src = item.img;
      img.onerror = () => { img.removeAttribute("src"); };

      const label = document.createElement("div");
      label.className = "label";
      label.textContent = item.name;

      card.addEventListener("dragstart", (e) => {
        e.dataTransfer.setData("text/itemId", item.id);
      });

      card.appendChild(img);
      card.appendChild(label);

      // Werte nur in der L√∂sung (und nur im Zeitstrahl)
      if (solutionShown && inSlot){
        const v = document.createElement("div");
        v.className = "label";
        v.style.opacity = "0.85";
        v.style.fontSize = "12px";
        v.textContent = formatValue(item.value);
        card.appendChild(v);
      } else {
        const spacer = document.createElement("div");
        spacer.style.height = "0px";
        card.appendChild(spacer);
      }

      if (inSlot){
        card.title = "Klick: zur√ºck in Pool";
        card.addEventListener("click", () => {
          if (solutionShown) return;

          const idx = indexOfItem(item.id);
          if (idx !== -1) slotPlacements[idx] = null;
          statusById[item.id] = "pool";
          if (lastPlacedId === item.id) lastPlacedId = null;
          if (idx !== -1) closeGapFromIndex(idx);
          renderAll();
        });
      }

      return card;
    }

    function escapeHtml(str){
      return String(str)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    /** ========= WIRE UI ========= */
    document.getElementById("checkBtn").addEventListener("click", () => verify());
    document.getElementById("solutionBtn").addEventListener("click", showSolution);
    document.getElementById("resetTimeline").addEventListener("click", () => resetTimeline());
    document.getElementById("shufflePool").addEventListener("click", () => {
      poolOrder = shuffle(poolOrder);
      renderPool();
    });
    document.getElementById("randomBtn").addEventListener("click", randomizeStart);
    document.getElementById("nextRound").addEventListener("click", () => nextRound());

    /** ========= INIT ========= */
    syncPlayers();
    initRound(0);
  </script>

</body>
</html>
